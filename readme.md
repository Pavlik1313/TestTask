<h1>Про мою реалізацію loadGrain</h1>

Давайте визначемо декілька термінів:

- Стінка - рівень баржі не нижчий від попереднього і вищий від наступного

![img_1.png](img_1.png)

рис.1: 1, 2, 3 та 4 - стінки



- Відсік - частина баржі, яка обмежена двома стінками, містить лише стінки не вищі(!) від тих, що обмежують відсік та не належить іншому відсіку.

![img_2.png](img_2.png)

рис.2: 1 та 2 - відсіки



- Бар'єр - стінка, яка обмежує відсік

![img_3.png](img_3.png)

рис.3: 1, 2 та 3 - бар'єри



<h2>Про знаходження загального об'єму зерна</h2>


Об'єм зерна, яке ми можемо засипати в баржу рівний сумі об'ємів зерна, що ми можемо насипати на кожен рівень.

Ми не можемо сипати зерно на бар'єр. Зерно може засипатися лише у(на) відсіки. Об'єм зерна, яке ми можемо насипати на рівень відсіку, рівний різниці максимальної висоти засипання зерна в відсік і висоти даного рівня.
Максимальна висота засипання зерна в відсік рівна висоті нижчого із бар'єрів відсіку.

Отже для того, щоб обрахувати об'єм зерна, яке ми можемо засипати в баржу, перш за все слід знайти усі бар'єри, потім для кожного відсіку визначити максимальний рівень засипання, знайти об'єм зерна який можна засипати на кожен рівень і віднайти їх суму.

<h2>Про аргоритм знаходження бар'єрів.</h2>

Ітеруємо по масиву рівнів і якщо, поточний рівень є стінкою, превіряємо чи вищий він від попереднього бар'єру. 
Якщо так - даний рівень є бар'єром (адже відсік, який починається з попереднього бар'єру не може містити поточний рівень
за визначенням, а отже він завершується на ньому)

Якщо ж він не вищий від попереднього бар'єру, може бути бар'єром, якщо далі не знайдеться стінок вищих за поточну. 
Запишемо його до списку кандидатів на бар'єр, перед тим видаливши з цього списку всіх інших кандидатів нижчих від 
поточного, починаючи з кінця.

Якщо поточний рівень не є стінкою - він не може бути бар'єром, а отже ми його ігноруємо і переходимо до наступного.

Після того, як весь масив буде проітерованим, в списку кандидатів на бар'єр можуть залишитися рівні. Те що вони 
залишилися означає, що після них не знайшлося вищих стінок, а отже вони є бар'єрами. Конкатенуємо список кандидатів до
списку бар'єрів.

Повертаємо результат.

<h4>Декілька ньоансів: </h4>

- Перша стінка, яку ми знайдемо однозначно буде бар'єром. Для того, щоб для кожної стінки не перевіряти чи є вона першою, 
перед початком алгоритму припустимо, що у нас існує так би мовити абстрактний нульовий бар'єр висотою нуль, тоді перша ж 
стінка, яку ми знайдемо буе вищою від нульового бар'єру і буде визнана бар'єром.
- Першому рівневі для того, щоб бути стінкою достатньо бути вищим від другого (ажде поперднього він не має), а 
останньому, відповідно, достатньо бути вищим від передостаннього. Для того, щоб не прописувати для них особливі умови та,
щоб не отримати виключення спричинене зверненням до неіснуючого елемента масиву, перед виконанням алгоритму пошуку
бар'єрів, додамо до масиву рівнів по нульовому рівню на початок і в кінець.





